#!/usr/bin/env python3
"""
Usage:
    python -m replace_string.py Arguments defined at end of file (for now)

Requires:
    GITHUB_AUTH token in local environment

Description:
    Fundamentally, replaces a string with another string. It can do this for all
    repos on a github org, or specified repos. It can create the swap on a new
    branch or on a repo's existing branch; it can generate a new PR or not. You
    can specify an arbitrary number of swap pairs.

    Outputs a json file of: successful PRs made, repos where PRs were failed to
    be made, and repos with existing branches that were updated.

Notes:
    There is a small amount of hardcoded functionality and variable definitions
    at the end of the file, in the `__main__` section. It may be difficult to
    make this script fully generic, but this is pretty close.

    `swap_strings` (in shell_helpers.py) has hardcoded shell commands that are
    wonky due to OSX. If you're not on OSX you should examine and change them.
"""

import datetime
import logging
import sys
import time

from github_helpers import *
from shell_helpers import *

### TODO ###
"""
1. Figure out what argument options are needed to: specify 
2. Fix up `__main__` to pull in parse-pr-query results
"""



# Switch to DEBUG for additional debugging info
logging.basicConfig(stream=sys.stderr, level=logging.INFO)
LOG = logging.getLogger(__name__)

def main(org, root_dir, old_string, new_string, exclude_private=False, interactive=False):
    """
    Goes through all repos in an org, clones them (or switches to the default
    branch and then pulls latest changes), searches for the specified string, if
    found makes a new branch, switches the string with the new string, creates a
    pull request.

    * org (str): GitHub organization
    * root_dir (str): path to directory to clone repos (on Mac, may look like
      `/Users/<uname>/path/to/dir`
    * old_string: what string we're looking to see if each repo has
    * new_string: if old_string is found, what we should replace it with
    * exclude_private (bool): if True, script skips private repos (default
      False)
    * interactive (bool): if True, pauses before committing files upstream and
      awaits user confirmation
    """
    gh_headers = get_github_headers()
    branch_name = "tcril/fix-gh-org-url"
    commit_msg = "fix: update path to .github workflows to read from openedx org"
    pr_details = {
        "title": "Fix github url strings in .github workflows",
        "body": "## This PR was autogenerated\n\nThis pr replaces the old GitHub organization, github.com/edx, with the new GitHub organization, github.com/openedx, in .github/workflow files.\n\nLooking for people to provide review.\n\nRef: https://github.com/openedx/tcril-engineering/issues/42"
    }

    count_commits = 0
    count_prs = 0
    count_skipped = 0

    ts = str(datetime.datetime.now())[:19]
    filename = f"output/replace_existing_branch_{ts}.json"
    with open(filename, "w") as f:
        for repo_data in get_repos(gh_headers, org, exclude_private):
            (rname, ssh_url, dbranch, _, count) = repo_data
            LOG.info("\n\n******* CHECKING REPO: {} ({}) ************".format(rname, count))
            if rname == "cs_comments_service":
                LOG.info(" skipping (was test repo)")
                continue
            repo_path = get_repo_path(rname, root_dir)
            # clone repo; if exists, checkout the default branch & pull latest
            clone_repo(root_dir, repo_path, ssh_url, dbranch)

            # Search for the string; fail fast if none exist
            if not found(old_string, repo_path):
                LOG.info("Did not find string {}".format(old_string))
                count_skipped += 1
                f.write(f"NO STRING: {rname}\n")
                continue

            # Checkout the already-existing branch_name
            branch_created = False
            if not checkout_branch(repo_path, branch_name):
                # this branch was never created, or already merged, so
                # create it for the new commit
                new_branch(repo_path, branch_name)
                branch_created = True

            # Swap old string for new string
            swap_strings(old_string, new_string, repo_path)
            if interactive:
                try:
                    interactive_commit(repo_path)
                except RepoError:
                    # move on to next repo
                    continue

            make_commit(repo_path, commit_msg)

            if branch_created:
                try:
                    LOG.info(f" Making a pull request")
                    pr_url = make_pr(gh_headers, org, rname, branch_name, dbranch, pr_details)
                    f.write(f"CREATED PR: {pr_url}\n")
                    count_prs += 1
                except PrCreationError as pr_err:
                    LOG.info(pr_err.__str__())
                    # info you need to retry
                    f.write(f"FAILED TO MAKE PR: {org}, {rname}, {branch_name}, {dbranch}, {pr_details}\n")
            else:
                LOG.info(f" committed to existing branch")
                f.write(f"CREATED COMMIT: {rname}\n")
                count_commits += 1

            time.sleep(5)

    LOG.info(
        f"Processed {count} repos; {count_prs} PRs successfully made and {count_commits} commits created on existing branches"
    )
    LOG.info(f"Skipped {count_skipped} repos as string didn't exist")


if __name__ == "__main__":
    root_dir = "/Users/sarinacanelake/openedx/"
    old_string = "uses: edx/.github"
    new_string = "uses: openedx/.github"
    main("openedx", root_dir, old_string, new_string, exclude_private=False, interactive=False)
