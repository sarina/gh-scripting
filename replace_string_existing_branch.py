#!/usr/bin/env python3
"""
Usage:
    python -m replace_string_existing_branch.py

Requires:
    GITHUB_AUTH token in local environment

Description:
    Assumes you've run `replace_string_with_another`, thus repos already have
    your working branch defined, and you don't want to open a new set of PRs.

    Checks out existing branch (or re-creates if existing was already merged)
    and performs another string swap with the new strings, and makes a new
    commit.

Note:
    swap_strings has hardcoded shell commands that are wonky due to OSX. If
    you're not on OSX you should examine and change them.
"""

## Steps
# 1. check if strings exist on default_branch
# 2. if so try to check out branch; if that fails, create a new branch.
# 3. script as defined??

import datetime
import logging
import subprocess
import sys
import time

from ghelpers import *


# Switch to DEBUG for additional debugging info
logging.basicConfig(stream=sys.stderr, level=logging.INFO)
LOG = logging.getLogger(__name__)

def main(org, root_dir, old_string, new_string, exclude_private=False, interactive=False):
    """
    Goes through all repos in an org, clones them (or switches to the default
    branch and then pulls latest changes), searches for the specified string, if
    found makes a new branch, switches the string with the new string, creates a
    pull request.

    * org (str): GitHub organization
    * root_dir (str): path to directory to clone repos (on Mac, may look like
      `/Users/<uname>/path/to/dir`
    * old_string: what string we're looking to see if each repo has
    * new_string: if old_string is found, what we should replace it with
    * exclude_private (bool): if True, script skips private repos (default
      False)
    * interactive (bool): if True, pauses before committing files upstream and
      awaits user confirmation
    """
    gh_headers = get_github_headers()
    branch_name = "tcril/fix-gh-org-url"
    commit_msg = "fix: update path to .github workflows to read from openedx org"
    pr_details = {
        "title": "Fix github url strings in .github workflows",
        "body": "## This PR was autogenerated\n\nThis pr replaces the old GitHub organization, github.com/edx, with the new GitHub organization, github.com/openedx, in .github/workflow files.\n\nLooking for people to provide review.\n\nRef: https://github.com/openedx/tcril-engineering/issues/42"
    }

    count_commits = 0
    count_prs = 0
    count_skipped = 0

    ts = str(datetime.datetime.now())[:19]
    filename = f"output/run_edxlint_{ts}.json"
    with open(filename, "w") as f:
        for repo_data in get_repos(gh_headers, org, exclude_private):
            (rname, ssh_url, dbranch, _, count) = repo_data
            LOG.info("\n\n******* CHECKING REPO: {} ({}) ************".format(rname, count))

            repo_path = get_repo_path(rname, root_dir)
            # clone repo; if exists, checkout the default branch & pull latest
            clone_repo(root_dir, repo_path, ssh_url, dbranch)

            # Search for the string; fail fast if none exist
            if not found(old_string, repo_path):
                LOG.info("Did not find string {}".format(old_string))
                count_skipped += 1
                f.write(f"NO STRING: {rname}\n")
                continue

            # Checkout the already-existing branch_name
            branch_created = False
            if not checkout_branch(repo_path, branch_name):
                # this branch was never created, or already merged, so
                # create it for the new commit
                new_branch(repo_path, branch_name)
                branch_created = True

            # Swap old string for new string
            swap_strings(old_string, new_string, repo_path)
            if interactive:
                try:
                    interactive_commit(repo_path)
                except RepoError:
                    # move on to next repo
                    continue

            make_commit(repo_path, commit_msg)

            if branch_created:
                try:
                    LOG.info(f" Making a pull request")
                    pr_url = make_pr(gh_headers, org, rname, branch_name, dbranch, pr_details)
                    f.write(f"CREATED PR: {pr_url}")
                    count_prs += 1
                except PrCreationError as pr_err:
                    LOG.info(pr_err.__str__())
                    # info you need to retry
                    f.write(f"FAILED TO MAKE PR: {org}, {rname}, {branch_name}, {dbranch}, {pr_details}")
            else:
                LOG.info(f" committed to existing branch")
                f.write(f"CREATED COMMIT: {rname}")
                count_commits += 1

            # Without, you hit secondary rate limits if you have more than ~30
            # repos. I tried 3, too short. 5, got through 80. 30, totally worked.
            # there's a good number in between that i'm sure but they don't help
            # much. From GH docs: Requests that create content which triggers
            # notifications, such as issues, comments and pull requests, may be
            # further limited and will not include a Retry-After header in the
            # response. Please create this content at a reasonable pace to avoid
            # further limiting.
            time.sleep(30)

    LOG.info(
        f"Processed {count} repos; {count_prs} PRs successfully made and {count_commits} commits created on existing branches"
    )
    LOG.info(f"Skipped {count_skipped} repos as string didn't exist")


def found(old_string, repo_path):
    """
    Looks through the repo specified by `repo_path` to see if there are any
    occurances of `old_string`

    Returns bool: True if the string is found, else False
    """
    # grep -r old_string . returns an array of which files match the string.
    proc = subprocess.Popen(
        f"grep -r {old_string} .",
        cwd=repo_path,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=True
    )
    res, _ = proc.communicate()
    return len(res) > 0


def swap_strings(old_string, new_string, repo_path):
    """
    Replaces all occurances of `old_string` in the repo with `new_string`
    recursively starting in the root directory given by `repo_path`

    Does not inspect the `.git/` directory.
    """
    # Command one: Look for files with the old_string, skipping the .git directorys
    c1 = f'/usr/bin/grep -rl --exclude-dir=.git "{old_string}"'

    # Command two: Swap!
    # delimiter for sed; rather than escape we'll use _ if we're replacing a URL
    d = "/"
    if "/" in old_string or "/" in new_string:
        d = "_"
    # NOTE!!! This is the OSX command, drop `LC_ALL=C` and `'' -e` if not OSX!
    c2 = f"LC_ALL=C /usr/bin/xargs /usr/bin/sed -i '' -e 's{d}{old_string}{d}{new_string}{d}g'"

    # Now chain those calls together in a subprocess wheee
    chained = c1 + " | " + c2
    proc = subprocess.Popen(
        chained,
        cwd=repo_path,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=True
    )

    _ = proc.communicate()


if __name__ == "__main__":
    root_dir = "/Users/sarinacanelake/openedx/"
    old_string = "github.com/edx"
    new_string = "github.com/openedx"
    main("openedx", root_dir, old_string, new_string, exclude_private=False, interactive=False)
